const config = require("./config");
const mongo = require("./mongoFunctions.js");
const iconv = require("iconv-lite");
const fs = require("fs");
const jsdom = require("jsdom"); // this module takes some time to load :(
const { JSDOM } = jsdom;
/**
 * Template for single substitution object
 * @constant
*/
const singleSub = { // changes field not added; should look like: `"changes": { "teachers": ["new teacher"] }`
	"cancelled": [false], //bool
	"note": [""], //string
	"substitution_types": [""], //string
	"type": ["card"], //leave it as it is (IDK what it is)
	"periods": [""], //number (or number as string); lesson number
	"subjects": [""], //string
	"teachers": [""], //string
	"classes": [""], //string
	"classrooms": [""], //string
	"groupnames": [""], //string (not necessary)
	"periodorbreak": [""], //string (not necessary, IDK what it is)
	"moje": [false] //leave it as it is (IDK what it is)
};
/** Classroom numbers not being numbers (Not Standard Classroom Number) */
const nscNum = ["POÅš", "PJA", "PA2", "PK2", "PK1", "PK3", "PK4", "PK5", "PK6", "PK7"];
const classNumbers = ["2GA", "2GB", "3GA", "3GB", "1La", "1Lb", "1Ls", "2La", "2Lb", "2Ls", "3La", "3Lb", "3Ls", "1Ta", "1Tb", "2Ta", "2Tb", "3Ta", "3Tb", "4Ta", "4Tb"]; //TODO: move to config (ncsNum too)
/**
 * Remove file passed as parameter. Does not return/callback
 * @param {string} file File to be removed (path)
*/
function del(file){
	fs.unlink(file, (err) => {
		if (err){
			console.error("File could not be removed:", err);
		} else {
			console.info("File:", file, "deleted successfully.");
		}
	});
}
/**
 * Based on err parameter copy file to ../error/ or ../parsed/ and remove it
 * @param {string|Error|NodeJS.ErrnoException} err Error passed from subF.parseAndSave in function findFile
 * @param {string} file File (path to file) to be copied
*/
function moveFile(err, file){
	if (err){
		console.error("Parsing and saving substitutions failed:", err);
		fs.copyFile(config.HTMLloc + "/" + file, config.HTMLloc + "/../error/" + file, (err2) => {
			if (err2){
				if (err2.code === "ENOENT"){
					console.warn("Error dir does not exist, creating...");
					fs.mkdir(config.HTMLloc + "/../error/", (error) => {
						if (!error){
							moveFile(err, file);
						} else {
							console.error("Cannot create error directory!");
						}
					});
				} else {
					console.error("Error copying file to error dir:", err2);
				}
			} else {
				del(config.HTMLloc + "/" + file);
			}
		});
	} else {
		fs.copyFile(config.HTMLloc + "/" + file, config.HTMLloc + "/../parsed/" + file, (err2) => {
			if (err2){
				if (err2.code === "ENOENT"){
					console.warn("Parsed dir does not exist, creating...");
					fs.mkdir(config.HTMLloc + "/../parsed/", (error) => {
						if (!error){
							moveFile(err, file);
						} else {
							console.error("Cannot create parsed directory!");
						}
					});
				} else {
					console.error("Error copying file to parsed dir:", err2);
				}
			} else {
				del(config.HTMLloc + "/" + file);
			}
		});
	}
}
/**
 * Read file as latin-2 and resolve promise with document (as DOM element)
 * @param {string} file Path of html file that has to be converted
 * @returns {Promise<Document>} Promise that resolves with a DOM document ready for parsing
*/
function latin2ToDOM(file){
	return new Promise((resolve, reject) => {
		/** @type {Document} */
		var document;
		try {
			// Reading ISO-8859-2 file - no encoding provided, decoding buffer, faster than with encoding: binary
			var input = fs.readFileSync(file);
			var outputConv = iconv.decode(input, "ISO-8859-2");
			// Extract document from DOM generated by JSDOM
			document = (new JSDOM(outputConv)).window.document;
		} catch (error){
			reject(error);
		}
		resolve(document);
	});
}
/**
 * Object (class) containing substitutions for one day that allows to convert HTML
 * generated by Vulcan to our JSON object saved in DB
 * @param {string} file path to file which has to be converted
 * @param {string} fileName name of file
 * @param {Function} callback callback function
 * @constructor
*/
var Substitutions = function(file, fileName, callback){
	this.fileName = fileName;
	this.subArr = {
		"_id": "",
		"substitution": [],
		"userList": [],
		"date": "",
		"teachersList": []
	};
	latin2ToDOM(file)
		.then((document) => {
			this.document = document;
			this.table = document.getElementsByTagName("table")[0];
			this.rows = document.getElementsByTagName("tbody")[0].children;
			setImmediate(() => {
				callback(null);
			});
		})
		.catch((err) => {
			console.error("Reading and parsing file failed:", err);
			setImmediate(() => {
				callback(err);
			});
		});
};
/**
 * Extracts date from first row of table and saves it in this.subArr as _id and date parameters
*/
Substitutions.prototype.getFileDate = function(){
	var dateReg = /[\s\S]*(\d{1}|\d{2})\.(\d{2})\.(\d{4})[\s\S]*/; // match whole string and save day month and year groups d.mm.yyyy or dd.mm.yyyy
	/**
	 * Substitution date found using dateReg in table header and converted to yyyy-mm-(d)d
	 * @see https://regexr.com/3kt0l Example
	 * @type {string|null}
	*/
	var dat = this.table.getElementsByClassName("st0")[0].textContent.replace(dateReg, "$3-$2-$1");
	if (dat == null || dat.length < 9 || dat.length > 10){
		console.error("Date is null or incorrect:", dat, this.table.getElementsByClassName("st0")[0].textContent.match(dateReg)[0]);
		throw new Error("Date is null or incorrect: " + dat + "\n" + this.table.getElementsByClassName("st0")[0].textContent.match(dateReg)[0]);
	}
	if (dat.length == 9){
		// if date is yyyy-mm-d convert it to yyyy-mm-0d ($10 is $1 + 0 not 10 - it works)
		dat = dat.replace(/(\d{4}-\d{2}-)(\d{1})/, "$10$2");
	}
	this.subArr._id = dat;
	this.subArr.date = dat;
};
/**
 * Push teacher's name to teachers list avoiding duplicates
 * @param {string} newTeacher Teacher to be added
 * @this Substitutions
*/
Substitutions.prototype.addTeacher = function(newTeacher){
	if (!this.subArr.teachersList.includes(newTeacher)) this.subArr.teachersList.push(newTeacher); // add teacher to teacherList (if wasn't there earlier)
};
/**
 * Push converted class name to class list avoiding duplicates
 * @param {string} newClass Class name to be added
*/
Substitutions.prototype.addClass = function(newClass){
	if (!this.subArr.userList.includes(newClass)) this.subArr.userList.push(this.convClass(newClass));
};
/**
 * Convert class names (save "2 GB" and "2GB" as "2gb")
 * @param {string} newClass Class name to be converted
 * @return {string} Standardised class name
 */
Substitutions.prototype.convClass = (newClass) => {
	return newClass.replace(" ", "").toLowerCase();
};
/**
 * Remove whitespaces at beginning and end of each string.
 * Does not return; modifies parameter of object.
 * @param {Function} callback callback function, error or null passed as parameter
*/
Substitutions.prototype.cleanRow = function(callback){
	try{
		for(var a = 0; a < this.rows.length; a++){
			for(let b = 0; b < this.rows[a].childElementCount; b++){
				this.rows[a].children[b].textContent = this.rows[a].children[b].textContent.trim();
			}
		}
	} catch(err){
		setImmediate(() => {
			callback(err);
		});
	}
	setImmediate(() => {
		callback(null);
	});
};
/**
 * Does almost all of the parsing. Goes cell by cell, row by row through whole HTML table.
 * Creates and pushes to array single substitution objects, which consist of teacher name,
 * class name, lesson number, group number (if present), new teacher (if present), comment
 * (if present), new classroom number (if present) and parameter that tells whether the
 * lesson was cancelled or not that are recognized and extracted here.
 * @see singleSub
 * @param {Function} callback callback function, error passed as param (now it's always null)
*/
Substitutions.prototype.getSubstitutions = function(callback){
	var cSub = JSON.parse(JSON.stringify(singleSub)); //current substitution
	var cTeacher = [""]; //current teacher
	for(var i = 1; i < this.rows.length; i++){
		// Teacher field has class "st1", is the olnly child in row, is first after a row with 4 empty cells
		if (cTeacher[0] == "" && this.rows[i].childElementCount == 1 && this.rows[i].children[0].className == "st1"){
			cTeacher = this.rows[i].children[0].textContent; //save teacher name
			this.addTeacher(cTeacher);
			i++; // skip next row - it contains columns descriptions
		} else if (this.rows[i].childElementCount == 4){ // these rows may contain substitution data or be empty
			if (this.rows[i].children[0].className == this.rows[i].children[1].className &&
				this.rows[i].children[1].className == this.rows[i].children[2].className &&
				this.rows[i].children[2].className == this.rows[i].children[3].className){
				// if all cells have the same class we can assume that this row separates teachers, so we should reset it
				cTeacher = [""];
			} else {
				// this row contains substitution data
				cSub.teachers[0] = cTeacher;
				cSub.periods[0] = this.rows[i].children[0].textContent; // first cell contains lesson number
				var details = this.rows[i].children[1].textContent.split(" - ");
				var classAndGroup = details[0].split(/[()]/g); // Split by ( and )
				if (classAndGroup.length > 1){
					// group is specified; group should be at index 1 (if present)
					cSub.groupnames[0] = classAndGroup[1];
					cSub.classes[0] = this.convClass(classAndGroup[0]); // class will always be at index 0 if written as `2 GB(1)`
					this.addClass(this.convClass(classAndGroup[0]));
				} else {
					// We can't be sure if it doesn't contain group
					var splClass = classAndGroup[0].split(" ");
					if (splClass.length > 2){
						// If multiple classes it's like `J angielski 2La 2Ls`, not `2 GB(1)`; no need to use convClass
						for(var n = 0; n < splClass.length; n++){
							if (classNumbers.includes(splClass[n])){
								// It's a class number (name)
								if (cSub.classes[0] == ""){ // don't leave "" as class name/number
									cSub.classes[0] = splClass[n];
								} else {
									cSub.classes.push(splClass[n]);
								}
								this.addClass(splClass[n]);
							} else {
								// If it isn't a class name/number it has to be a group
								cSub.groupnames[0] += splClass[n];
							}
						}
					} else {
						cSub.classes[0] = classAndGroup[0]; // no group specified; class must be at index 0 in classAndGroup
						this.addClass(classAndGroup[0]);
					}
				}
				if (details[1] == "Uczniowie zwolnieni do domu" || details[1] == "Uczniowie przychodzÄ… pÃ³Åºniej"){
					// lesson is cancelled
					cSub.cancelled[0] = true;
				} else if (!isNaN(details[1]) | nscNum.includes(details[1])){
					// It's a number or is included in nscNum - so it has to be a classroom number
					cSub.classrooms[0] = details[1];
				} else if (details[1] != undefined && details[1].length > 0){
					cSub.note[0] = details[1];
				}
				if (this.rows[i].children[2].textContent.length > 0){
					// New teacher will be present on this lesson
					if (!cSub.changes) cSub.changes = {};
					cSub.changes.teachers = new Array(this.rows[i].children[2].textContent);
					this.addTeacher(this.rows[i].children[2].textContent);
				}
				if (this.rows[i].children[3].textContent.length > 0){
					// There is a note
					if (cSub.note[0].length > 0) cSub.note += "\n";
					cSub.note[0] += this.rows[i].children[3].textContent;
				}
				// End of row means end of single substitution. Push it to subArr and reset cSub
				this.subArr.substitution.push(cSub);
				cSub = JSON.parse(JSON.stringify(singleSub));
			}
		} else {
			console.error("Not recognized row:", this.rows[i].innerHTML);
			//Should we abort conversion?
		}
	}
	setImmediate(() => {
		callback(null);
	});
};
/**
 * Prepares object, launches parsing and saves it in DB
 * @param {Function} callback callback function, error and file name passed as parameters
*/
Substitutions.prototype.parseAndSave = function(callback){
	try {
		this.getFileDate();
	} catch (error){
		setImmediate(() => {
			callback(error, this.fileName);
		});
	}
	this.cleanRow((err) => {
		if (!err){
			this.getSubstitutions((err) => {
				if (!err){
					mongo.modifyById(this.subArr._id, "substitutions", this.subArr, function(){
						setImmediate(function(error) {
							if (error){
								callback("Error while saving to db: " + error, this.fileName);
							} else {
								callback(null, this.fileName);
							}
						});
					});
				} else {
					setImmediate((err) => {
						callback(err, this.fileName);
					});
				}
			});
		} else {
			setImmediate((err) => {
				callback(err, this.fileName);
			});
		}
	});
};
/**
 * Synchronously loop through files (recursive function),create an obect for each file,
 * parse it (and save), then move to parsed/error directory
 * (depending on whether parsing was successful)
 * @param {string[]} files array of names of files to be converted
 * @param {number} a index of file in array
*/
function loopFiles(files, a){
	if (a < files.length){
		var subF = new Substitutions(config.HTMLloc + "/" + files[a], files[a], (error) => {
			if (!error){
				subF.parseAndSave((err, file) => {
					moveFile(err, file);
				});
			}
		});
		loopFiles(files, a+1);
	}
}
/**
 * Reads files in directory specified in config and passes them to 'loop'
 * function, which tries to convert them.
 * Does not return anything, converted objects are saved in database.
*/
function findFile(){
	fs.readdir(config.HTMLloc, (err, files) => {
		if (!err){
			loopFiles(files, 0);
		} else {
			console.error("Directory could not be read:", err);
		}
	});
}
module.exports = findFile;
